<html>
    <head>
    <title>Tic tac toe</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .dot { fill: #4e79a7; opacity: 0.7; }
        .dot:hover { fill: #e15759; opacity: 1; }
        .axis-label { font-family: sans-serif; font-size: 12px; }
        .game-board {
            font-size: 50px;
            border: 11px solid blanchedalmond;
            border-collapse: collapse;
        }
        .game-board td {
            width: 100px;
            height: 100px;
            text-align: center;
            border: 11px solid blanchedalmond;
        }
        .banner {
            display: flex;
            position: absolute;
            top: 20%;
            left: 20%;
            bottom: 20%;
            right: 20%;
            text-align: center;
            vertical-align: middle;
            font-size: 70px;
            margin-top: 20px;
            border: 50px solid rgb(144, 244, 255);
            border-radius: 10px;
            background-color: rgb(145, 245, 256);
            justify-content:center;
            align-items:center;
        }

        #button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 20px;
            background-color: red;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    </head>
    <body>
        <h1>Tic Tac Toe Game</h1>
        <table>
            <tr>
                <td>Computer (O) Wins: <span id="computer-wins">0</span></td>
                <td>Random (X) Wins: <span id="random-wins">0</span></td>
                <td>Draws: <span id="draws">0</span></td>
            </tr>
            <tr>
                <td>Loss: <span id="loss">0</span></td>
            </tr>
        </table>
        <div id="chart"></div>
        <div id="button">START</div>
        <table id="game-board" class="game-board">
            <tr>
                <td id="cell-0,0"></td>
                <td id="cell-0,1"></td>
                <td id="cell-0,2"></td>
            </tr>
            <tr>
                <td id="cell-1,0"></td>
                <td id="cell-1,1"></td>
                <td id="cell-1,2"></td>
            </tr>
            <tr>
                <td id="cell-2,0"></td>
                <td id="cell-2,1"></td>
                <td id="cell-2,2"></td>
            </tr>
        </table>
        <div id="banner" class="banner" style="display:none">Player X win</div>
    </body>
    <script>

        let computerWins = 0;
        let randomWins = 0;
        let draws = 0;

        function createModel() {
            const model = tf.sequential();
            model.add(tf.layers.dense({ units: 64, inputShape: [9], activation: 'relu' }));
            model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
            model.add(tf.layers.dense({ units: 9 })); // Output: Q-value for each cell
            model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });
            return model;
        };
        const model = createModel();
        console.log(model.summary());
        
        const f = (x) => model.predict(x);
        const loss = (pred, label) => pred.sub(label).square().mean();
        const optimizer = tf.train.sgd(0.1);
    
        const board = document.getElementById('game-board');
        let currentPlayer = 'X';
        const gameState = [['','',''],['','',''],['','','']];

        function resetGame() {
            gameState.forEach(row => row.fill(''));
            board.querySelectorAll('td').forEach(cell => cell.textContent = '');
        }

        let training = false;
        let lastInputs = [];
        let lastOutputs = [];
        let lastMoves = [];

        const last100Scores = [];

        function displayWinner(draw=false) {
            tf.tidy(() => {
                const inputs = lastInputs.map(input => input.slice());
                const outputs = lastOutputs.map(output => output.slice());
                const moves = lastMoves.slice()
                const lastMove = moves[moves.length - 1];

                
                if (draw) {
                    for (let i = 0; i < inputs.length; i++) {
                        outputs[i][moves[i]] = Math.min(1, outputs[i][moves[i]] + 0.2);
                    }
                    draws += 1;
                    last100Scores.push(0);
                } else if (currentPlayer === 'X') {
                    for (let i = 0; i < inputs.length; i++) {
                        outputs[i][moves[i]] = Math.max(-1, outputs[i][moves[i]] - 0.5);
                    }
                    randomWins += 1;
                    last100Scores.push(1);
                } else {
                    for (let i = 0; i < inputs.length; i++) {
                        outputs[i][moves[i]] = Math.min(1, outputs[i][moves[i]] + 0.5);
                    }
                    computerWins += 1;
                    last100Scores.push(0);
                }
                if (last100Scores.length > 100) {
                    last100Scores.shift();
                }

                //console.log('Game ended. Updating model.', inputs, outputs, moves);

                const inputTensor = tf.tensor2d(inputs);
                const targetTensor = tf.tensor2d(outputs);
                const lossTensor = optimizer.minimize(() => {
                    const pred = f(inputTensor);
                    return loss(pred, targetTensor);
                }, true);
                document.getElementById('computer-wins').textContent = computerWins;
                document.getElementById('random-wins').textContent = randomWins;
                document.getElementById('draws').textContent = draws;
                document.getElementById('loss').textContent = lossTensor.dataSync()[0].toFixed(4);
            });

            lastInputs = [];
            lastOutputs = [];
            lastMoves = [];

            updateChart();

            if (!training) {
                document.getElementById('banner').style.display = 'flex';
                if (draw) {
                    document.getElementById('banner').textContent = `It's a draw!`;
                } else {
                    document.getElementById('banner').textContent = `Player ${currentPlayer} win!`;
                }
                setTimeout(() => {
                    document.getElementById('banner').style.display = 'none';
                    resetGame();
                }, 500);
            } else {
                resetGame();
            }
        }

        function check() {
            if (gameState[0][0] == currentPlayer && gameState[0][1] == currentPlayer && gameState[0][2] == currentPlayer) {
                displayWinner();
                return true;
            }
            if (gameState[1][0] == currentPlayer && gameState[1][1] == currentPlayer && gameState[1][2] == currentPlayer) {
                displayWinner();
                return true;
            }
            if (gameState[2][0] == currentPlayer && gameState[2][1] == currentPlayer && gameState[2][2] == currentPlayer) {
                displayWinner();
                return true;
            }
            if (gameState[0][0] == currentPlayer && gameState[1][0] == currentPlayer && gameState[2][0] == currentPlayer) {
                displayWinner();
                return true;
            }
            
            if (gameState[0][1] == currentPlayer && gameState[1][1] == currentPlayer && gameState[2][1] == currentPlayer) {
                displayWinner();
                return true;
            }
            if (gameState[0][2] == currentPlayer && gameState[1][2] == currentPlayer && gameState[2][2] == currentPlayer) {
                displayWinner();
                return true;
            }
            if (gameState[0][2] == currentPlayer && gameState[1][1] == currentPlayer && gameState[2][0] == currentPlayer) {
                displayWinner();
                return true;
            }
            if (gameState[0][0] == currentPlayer && gameState[1][1] == currentPlayer && gameState[2][2] == currentPlayer) {
                displayWinner();
                return true;
            }
            var draw = true;
            for (var i = 0; i < 3; ++i) {
                for (var j = 0; j < 3; ++j) {
                    if (gameState[i][j] == '') {
                        draw = false;
                    }
                }
            }
            
            if (draw) {
                displayWinner(true);
                resetGame();
                return true;
            }
        
            return false;
        }

        function computerMove() {
            setTimeout(() => {
                const input = [];
                for (let i = 0; i < 9; i++) {
                    const row = Math.floor(i / 3);
                    const col = i % 3;
                    input.push(gameState[row][col] === 'X' ? 1 : gameState[row][col] === 'O' ? -1 : 0);
                }
                lastInputs.push(input.slice());
                const inputTensor = tf.tensor2d([input]);
                const outputTensor = model.predict(inputTensor);
                const outputData = Array.from(outputTensor.dataSync());
                lastOutputs.push(outputData.slice());
              
                let row = -1;
                let col = -1;
                let bestMove = -1;
                let bestValue = -Infinity;
                
                for (let i = 0; i < 9; i++) {
                    const r = Math.floor(i / 3);
                    const c = i % 3;
                    if (gameState[r][c] === '' && outputData[i] > bestValue) {
                        bestValue = outputData[i];
                        bestMove = i;
                        row = r;
                        col = c;
                    }
                } 
                lastMoves.push(bestMove);
            
                gameState[row][col] = 'O';
                document.getElementById(`cell-${row},${col}`).textContent = 'O';
                check();
                currentPlayer = 'X';
            }, 0);
        }

        function playRandomMove() {
            if (currentPlayer !== 'X') {
                return;
            }
            const emptyCells = [];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (gameState[i][j] === '') {
                        emptyCells.push([i, j]);
                    }
                }
            }
            if (emptyCells.length === 0) {
                return;
            }
            const randomIndex = Math.floor(Math.random() * emptyCells.length);
            const [row, col] = emptyCells[randomIndex];
            gameState[row][col] = 'X';
            document.getElementById(`cell-${row},${col}`).textContent = 'X';
            if (check()) {
                return;
            }
            currentPlayer = 'O';
            computerMove();
        }

        board.addEventListener('click', function(event) {
            const target = event.target;

            if (currentPlayer !== 'X') {
                return;
            }

            if (target.tagName === 'TD' && target.textContent === '') {
                const coordinate = target.id.split("-")[1].split(",");

                target.textContent = 'X';
                gameState[coordinate[0]][coordinate[1]] = 'X'

                if (check()) {
                    return;
                }

                currentPlayer = 'O';
                computerMove();
            }
        });

        // State of the training, if it is null no training is happening, otherwise it holds the interval ID.
        let intervalId = null;

        document.getElementById('button').addEventListener('click', function() {
            if (intervalId) {
                clearInterval(intervalId);
                training = false;
                intervalId = null;
                this.textContent = 'Start';
                return;
            }
            this.textContent = 'Stop';
            training = true;
            intervalId = setInterval(playRandomMove, 1); 
        });


        const chartData = [];

        // 2. Dimensions and Margins
        const margin = { top: 20, right: 30, bottom: 40, left: 50 },
            width = 500 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        const lineGenerator = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX); // Optional: makes the line smooth

        // 3. Create SVG Container
        const svg = d3.select("#chart")
            .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
            .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

        // 4. Create Scales
        // Map data values (0-200) to pixel values (0-width)
        const xScale = d3.scaleLinear()
            .domain([0, d3.max(chartData, d => d.x) + 10])
            .range([0, width]);

        // Map data values to pixels (height-0) -> Y is inverted in SVG
        const yScale = d3.scaleLinear()
            .domain([0, d3.max(chartData, d => d.y) + 10])
            .range([height, 0]);

        // 5. Add Axes
        svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(xScale));

        svg.append("g")
            .call(d3.axisLeft(yScale));

        // Add the path element once
        const path = svg.append("path")
            .datum(chartData) // Use .datum() for a single object (the whole array)
            .attr("class", "line-path")
            .attr("fill", "none")
            .attr("stroke", "#4e79a7")
            .attr("stroke-width", 2)
            .attr("d", lineGenerator);

        function updateChart() {
            if (computerWins + randomWins + draws > 0) {
                chartData.push({ x: computerWins + randomWins + draws, y: last100Scores.reduce((a, b) => a + b, 0) / last100Scores.length });
            }
            // 1. Always sort data by X so the line flows left-to-right
            chartData.sort((a, b) => a.x - b.x);

            // 2. Update scales
            xScale.domain(d3.extent(chartData, d => d.x));
            yScale.domain([0, d3.max(chartData, d => d.y)]);

            // 3. Update Axes
            svg.select(".x-axis").transition().duration(750).call(d3.axisBottom(xScale));
            svg.select(".y-axis").transition().duration(750).call(d3.axisLeft(yScale));

            // 4. Update the Path
            svg.select(".line-path")
                .datum(chartData)
                .attr("d", lineGenerator);        
        }

    </script>
</html>